--- .\tests\test_fuzzer_client.py	(original)
+++ .\tests\test_fuzzer_client.py	(refactored)
@@ -169,7 +169,7 @@
         self.fuzzer.wait_until_done()
         info = self.fuzzer._get_session_info()
         reports = self.fuzzer.dataman.get_report_test_ids()
-        self.assertEqual(sorted(reports), sorted([int(x) for x in config.keys() if x != 'always']))
+        self.assertEqual(sorted(reports), sorted([int(x) for x in list(config.keys()) if x != 'always']))
         self.assertEqual(info.failure_count, len(config) - 1)
 
     def testAllFailedTestsHaveReports(self):
@@ -186,7 +186,7 @@
         self.fuzzer.wait_until_done()
         info = self.fuzzer._get_session_info()
         reports = self.fuzzer.dataman.get_report_test_ids()
-        self.assertEqual(sorted(reports), sorted([int(x) for x in config.keys() if x != 'always']))
+        self.assertEqual(sorted(reports), sorted([int(x) for x in list(config.keys()) if x != 'always']))
         self.assertEqual(info.failure_count, len(config) - 1)
 
     def testStoringAllReportsWhenStoreAllReportsIsSetToTrue(self):
@@ -234,7 +234,7 @@
         self.fuzzer.start()
         self.fuzzer.wait_until_done()
         self.assertIn(0, self.mutations)
-        self.assertEquals(self.mutations[0][0][0], self._default_stage)
+        self.assertEqual(self.mutations[0][0][0], self._default_stage)
         self.assertIsNotNone(self.mutations[0][0][1])
 
     def testGetMutationForStageTwice(self):
@@ -255,9 +255,9 @@
         self.fuzzer.start()
         self.fuzzer.wait_until_done()
         self.assertIn(0, self.mutations)
-        self.assertEquals(self.mutations[0][0][0], self._default_stage)
+        self.assertEqual(self.mutations[0][0][0], self._default_stage)
         self.assertIsNotNone(self.mutations[0][0][1])
-        self.assertEquals(self.mutations[0][1][0], self._default_stage)
+        self.assertEqual(self.mutations[0][1][0], self._default_stage)
         self.assertIsNotNone(self.mutations[0][1][1])
 
     def testGetMutationWrongStage(self):
@@ -278,7 +278,7 @@
         self.fuzzer.start()
         self.fuzzer.wait_until_done()
         self.assertIn(0, self.mutations)
-        self.assertEquals(self.mutations[0][0][0], wrong_stage)
+        self.assertEqual(self.mutations[0][0][0], wrong_stage)
         self.assertIsNone(self.mutations[0][0][1])
 
     def testGetMutationWrongAfterCorrectStage(self):
@@ -300,9 +300,9 @@
         self.fuzzer.start()
         self.fuzzer.wait_until_done()
         self.assertIn(0, self.mutations)
-        self.assertEquals(self.mutations[0][0][0], self._default_stage)
+        self.assertEqual(self.mutations[0][0][0], self._default_stage)
         self.assertIsNotNone(self.mutations[0][0][1])
-        self.assertEquals(self.mutations[0][1][0], wrong_stage)
+        self.assertEqual(self.mutations[0][1][0], wrong_stage)
         self.assertIsNone(self.mutations[0][1][1])
 
     def testGetMutationCorrectAfterWrongStage(self):
@@ -324,9 +324,9 @@
         self.fuzzer.start()
         self.fuzzer.wait_until_done()
         self.assertIn(0, self.mutations)
-        self.assertEquals(self.mutations[0][0][0], wrong_stage)
+        self.assertEqual(self.mutations[0][0][0], wrong_stage)
         self.assertIsNone(self.mutations[0][0][1])
-        self.assertEquals(self.mutations[0][1][0], self._default_stage)
+        self.assertEqual(self.mutations[0][1][0], self._default_stage)
         self.assertIsNotNone(self.mutations[0][1][1])
 
     def testGetMutationWithWildcard(self):
@@ -346,5 +346,5 @@
         self.fuzzer.start()
         self.fuzzer.wait_until_done()
         self.assertIn(0, self.mutations)
-        self.assertEquals(self.mutations[0][0][0], ClientFuzzer.STAGE_ANY)
+        self.assertEqual(self.mutations[0][0][0], ClientFuzzer.STAGE_ANY)
         self.assertIsNotNone(self.mutations[0][0][1])
--- .\tests\test_fuzzer_server.py	(original)
+++ .\tests\test_fuzzer_server.py	(refactored)
@@ -204,7 +204,7 @@
         self.fuzzer.set_target(self.target)
         self.fuzzer.start()
         pre_test_list = self.target.instrument.list_get('pre_test')
-        self.assertListEqual(pre_test_list, range(2, 11))
+        self.assertListEqual(pre_test_list, list(range(2, 11)))
 
         os.remove(session_file_name)
 
@@ -229,7 +229,7 @@
         self.fuzzer.set_target(self.target)
         self.fuzzer.start()
         pre_test_list = self.target.instrument.list_get('pre_test')
-        self.assertListEqual(pre_test_list, range(-1, 11))
+        self.assertListEqual(pre_test_list, list(range(-1, 11)))
         self.fuzzer.stop()
 
         self.logger.info('Now use the same session file to rerun failed tests')
@@ -313,7 +313,7 @@
         self.fuzzer.start()
         info = self.fuzzer._get_session_info()
         reports = self.fuzzer.dataman.get_report_test_ids()
-        self.assertEqual(reports, [int(x) for x in config.keys()])
+        self.assertEqual(reports, [int(x) for x in list(config.keys())])
         self.assertEqual(info.failure_count, len(config))
 
     def testAllFailedTestsHaveReports(self):
@@ -328,7 +328,7 @@
         self.fuzzer.start()
         info = self.fuzzer._get_session_info()
         reports = self.fuzzer.dataman.get_report_test_ids()
-        self.assertEqual(reports, sorted([int(x) for x in config.keys()]))
+        self.assertEqual(reports, sorted([int(x) for x in list(config.keys())]))
         self.assertEqual(info.failure_count, len(config))
 
     def testStoringAllReportsWhenStoreAllReportsIsSetToTrue(self):
--- .\tests\test_model_high_level.py	(original)
+++ .\tests\test_model_high_level.py	(refactored)
@@ -88,7 +88,7 @@
                 sequences[sequence] += 1
         self.assertEqual(len(sequences), len(expected_sequences))
         self.logger.debug('check that each sequence appears the appropriate number of times')
-        for sequence, count in sequences.items():
+        for sequence, count in list(sequences.items()):
             seq_templates = [e.dst for e in sequence]
             self.assertIn(seq_templates, expected_sequences)
             last = seq_templates[-1]
@@ -235,7 +235,7 @@
         self.logger = get_test_logger()
         self.logger.debug('TESTING METHOD: %s', self._testMethodName)
         self.stage_lengths = self.get_stage_map()
-        self.stages = self.stage_lengths.keys()
+        self.stages = list(self.stage_lengths.keys())
         self.todo = []
 
     def get_stage_map(self):
--- .\tests\test_model_low_level_calculated.py	(original)
+++ .\tests\test_model_low_level_calculated.py	(refactored)
@@ -439,7 +439,7 @@
             ])
         rendered = container.render()
         self.assertEqual(len(rendered), self.length)
-        self.assertEquals(unpack('>I', rendered.tobytes())[0], self.length / 8)
+        self.assertEqual(unpack('>I', rendered.tobytes())[0], self.length / 8)
 
 
 class SizeInBytesTest(CalculatedTestCase):
--- .\tests\test_model_low_level_container.py	(original)
+++ .\tests\test_model_low_level_container.py	(refactored)
@@ -169,11 +169,11 @@
         rendered = container.render()
         for i in range(10):
             self.assertFalse(container.mutate())
-            self.assertEquals(container.render(), rendered)
+            self.assertEqual(container.render(), rendered)
         container.reset()
         for i in range(10):
             self.assertFalse(container.mutate())
-            self.assertEquals(container.render(), rendered)
+            self.assertEqual(container.render(), rendered)
 
     @metaTest
     def testNotFuzzable1(self):
@@ -222,13 +222,13 @@
             Group(name='test_group_5', values=['A', 'B', 'C'])
         ]
         container = self.get_default_container(fields)
-        expected_list = filter(lambda x: len(x.render()), fields)
+        expected_list = [x for x in fields if len(x.render())]
         if len(container.render()):
             self.assertListEqual(container.get_rendered_fields(), expected_list)
         else:
             self.assertListEqual(container.get_rendered_fields(), [])
         while container.mutate():
-            expected_list = filter(lambda x: len(x.render()), fields)
+            expected_list = [x for x in fields if len(x.render())]
             if len(container.render()):
                 self.assertEqual(container.get_rendered_fields(), expected_list)
             else:
@@ -840,7 +840,7 @@
         key_field = self.get_default_key_field()
         container = Container([uut, key_field])
         num_mutations = uut.num_mutations()
-        actual_num_mutations = sum(v.num_mutations() for k, v in field_dict.items())
+        actual_num_mutations = sum(v.num_mutations() for k, v in list(field_dict.items()))
         self.assertGreaterEqual(num_mutations, actual_num_mutations)
         del container
 
@@ -1040,7 +1040,7 @@
 
     def testRendersToEmptyBits(self):
         uut = PseudoTemplate('uut')
-        self.assertEquals(uut.render(), Bits())
+        self.assertEqual(uut.render(), Bits())
 
     def testNotFuzzable(self):
         uut = PseudoTemplate('uut')
--- .\tests\test_model_low_level_encoders.py	(original)
+++ .\tests\test_model_low_level_encoders.py	(refactored)
@@ -87,7 +87,7 @@
         expected_len = self._multibyte_len(bitfield._default_value)
         # bitfield.mutate()
         rendered = bitfield.render()
-        self.assertEquals(expected_len, len(rendered))
+        self.assertEqual(expected_len, len(rendered))
 
     def testUnsignedLength8(self):
         bitfield = BitField(
--- .\tests\test_model_low_level_fields.py	(original)
+++ .\tests\test_model_low_level_fields.py	(refactored)
@@ -198,9 +198,9 @@
     @metaTest
     def testReturnTypeMutateFuzzable(self):
         field = self.get_default_field(fuzzable=True)
-        self.assertIsInstance(field.mutate(), types.BooleanType)
-        field.reset()
-        self.assertIsInstance(field.mutate(), types.BooleanType)
+        self.assertIsInstance(field.mutate(), bool)
+        field.reset()
+        self.assertIsInstance(field.mutate(), bool)
 
     @metaTest
     def testReturnTypeRenderNotFuzzable(self):
@@ -223,9 +223,9 @@
     @metaTest
     def testReturnTypeMutateNotFuzzable(self):
         field = self.get_default_field(fuzzable=False)
-        self.assertIsInstance(field.mutate(), types.BooleanType)
-        field.reset()
-        self.assertIsInstance(field.mutate(), types.BooleanType)
+        self.assertIsInstance(field.mutate(), bool)
+        field.reset()
+        self.assertIsInstance(field.mutate(), bool)
 
     @metaTest
     def testHashTheSameForTwoSimilarObjects(self):
--- .\tests\test_model_low_level_mutated.py	(original)
+++ .\tests\test_model_low_level_mutated.py	(refactored)
@@ -23,15 +23,15 @@
         len_in_bits = len(value) * 8
         uut = self.get_field(value=value, num_bits=num_bits_to_flip)
         self.assertEqual(uut.num_mutations(), len_in_bits - num_bits_to_flip + 1)
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertEqual(set(mutations), set(expected_mutations))
 
     def testFlipSingleBitOnSingleByte(self):
-        expected_mutations = map(lambda i: chr(1 << i), range(8))
+        expected_mutations = [chr(1 << i) for i in range(8)]
         self._testBase(b'\x00', 1, expected_mutations)
 
     def testFlipTwoBitsOnSingleByte(self):
-        expected_mutations = map(lambda i: chr(3 << i), range(7))
+        expected_mutations = [chr(3 << i) for i in range(7)]
         self._testBase(b'\x00', 2, expected_mutations)
 
     def testFlipAllBitsOnSingleByte(self):
@@ -39,19 +39,19 @@
         self._testBase(b'\x00', 8, expected_mutations)
 
     def testFlipSingleBitOnTwoBytes(self):
-        expected_mutations = map(lambda i: pack('>H', 1 << i), range(16))
+        expected_mutations = [pack('>H', 1 << i) for i in range(16)]
         self._testBase(b'\x00\x00', 1, expected_mutations)
 
     def testFlipTwoBitsOnTwoBytes(self):
-        expected_mutations = map(lambda i: pack('>H', 3 << i), range(15))
+        expected_mutations = [pack('>H', 3 << i) for i in range(15)]
         self._testBase(b'\x00\x00', 2, expected_mutations)
 
     def testFlipTenBitsOnTwoBytes(self):
-        expected_mutations = map(lambda i: pack('>H', 0x3ff << i), range(7))
+        expected_mutations = [pack('>H', 0x3ff << i) for i in range(7)]
         self._testBase(b'\x00\x00', 10, expected_mutations)
 
     def testFlipAllBitsOnTwoBytes(self):
-        expected_mutations = map(lambda i: pack('>H', 0xffff << i), range(1))
+        expected_mutations = [pack('>H', 0xffff << i) for i in range(1)]
         self._testBase(b'\x00\x00', 16, expected_mutations)
 
     def testFuzzableIsFalse(self):
@@ -107,30 +107,30 @@
         total_bits = num_bytes * 8
         for num_bits in num_bits_itr:
             mask = (1 << num_bits) - 1
-            generated.extend(map(lambda x: pack(fmt, mask << x), range(total_bits - num_bits + 1)))
+            generated.extend([pack(fmt, mask << x) for x in range(total_bits - num_bits + 1)])
         return generated
 
     def _testBase(self, num_bytes, itr, uut=None):
         if uut is None:
             uut = BitFlips(b'\x00' * num_bytes, itr)
         expected_mutations = self._generate_mutations(num_bytes, itr)
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertGreaterEqual(len(mutations), len(expected_mutations))
         for em in expected_mutations:
             self.assertIn(em, mutations)
 
     def testSingleByteDefaultRangeIs1to5(self):
         uut = BitFlips(b'\x00')
-        expected_mutations = self._generate_mutations(1, range(1, 5))
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        expected_mutations = self._generate_mutations(1, list(range(1, 5)))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertGreaterEqual(len(mutations), len(expected_mutations))
         for em in expected_mutations:
             self.assertIn(em, mutations)
 
     def testTwoBytesDefaultRangeIs1to5(self):
         uut = BitFlips(b'\x00\x00')
-        expected_mutations = self._generate_mutations(2, range(1, 5))
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        expected_mutations = self._generate_mutations(2, list(range(1, 5)))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertGreaterEqual(len(mutations), len(expected_mutations))
         for em in expected_mutations:
             self.assertIn(em, mutations)
@@ -139,7 +139,7 @@
         self._testBase(1, [1])
 
     def testSingleByteMaximumRange(self):
-        self._testBase(1, range(1, 9))
+        self._testBase(1, list(range(1, 9)))
 
     def testSingleByteArbitraryRange(self):
         self._testBase(1, [1, 4, 6, 3])
@@ -148,7 +148,7 @@
         self._testBase(4, [1])
 
     def testMultipleBytesMaximumRange(self):
-        self._testBase(4, range(1, 33))
+        self._testBase(4, list(range(1, 33)))
 
     def testMultipleBytesArbitraryRange(self):
         self._testBase(4, [5, 19, 22, 27, 6])
@@ -203,10 +203,10 @@
     def _testFlipBytes(self, bytes_to_flip, value_len):
         value = '\x00' * value_len
         nf_count = value_len - bytes_to_flip
-        expected_mutations = map(lambda i: '\x00' * (nf_count - i) + '\xff' * bytes_to_flip + '\x00' * (i), range(nf_count + 1))
+        expected_mutations = ['\x00' * (nf_count - i) + '\xff' * bytes_to_flip + '\x00' * (i) for i in range(nf_count + 1)]
         uut = ByteFlip(value=value, num_bytes=bytes_to_flip)
         self.assertEqual(uut.num_mutations(), value_len - bytes_to_flip + 1)
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertEqual(set(mutations), set(expected_mutations))
 
     def testFlipSingleByteOnSingleByte(self):
@@ -273,7 +273,7 @@
 
     def _generate_single(self, value_len, bytes_to_flip):
         nf_count = value_len - bytes_to_flip
-        expected_mutations = map(lambda i: '\x00' * (nf_count - i) + '\xff' * bytes_to_flip + '\x00' * (i), range(nf_count + 1))
+        expected_mutations = ['\x00' * (nf_count - i) + '\xff' * bytes_to_flip + '\x00' * (i) for i in range(nf_count + 1)]
         return expected_mutations
 
     def _generate_mutations(self, value_len, num_bytes_itr):
@@ -286,7 +286,7 @@
         if uut is None:
             uut = ByteFlips(b'\x00' * num_bytes, itr)
         expected_mutations = self._generate_mutations(num_bytes, itr)
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertGreaterEqual(len(mutations), len(expected_mutations))
         for em in expected_mutations:
             self.assertIn(em, mutations)
@@ -294,7 +294,7 @@
     def testFourByteDefaultRangeIs124(self):
         uut = ByteFlips(b'\x00\x00\x00\x00')
         expected_mutations = self._generate_mutations(4, [1, 2, 4])
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertGreaterEqual(len(mutations), len(expected_mutations))
         for em in expected_mutations:
             self.assertIn(em, mutations)
@@ -302,7 +302,7 @@
     def testTenBytesDefaultRangeIs124(self):
         uut = ByteFlips(b'\x00' * 10)
         expected_mutations = self._generate_mutations(10, [1, 2, 4])
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertGreaterEqual(len(mutations), len(expected_mutations))
         for em in expected_mutations:
             self.assertIn(em, mutations)
@@ -314,7 +314,7 @@
         self._testBase(4, [1])
 
     def testMultipleBytesMaximumRange(self):
-        self._testBase(4, range(1, 5))
+        self._testBase(4, list(range(1, 5)))
 
     def testMultipleBytesArbitraryRange(self):
         self._testBase(20, [7, 12, 9, 3, 19])
@@ -369,7 +369,7 @@
         super(BlockOperationTests, self).setUp(cls)
 
     def _default_value(self, data_size):
-        return ''.join(map(lambda x: chr(x % 0x100), range(data_size)))
+        return ''.join([chr(x % 0x100) for x in range(data_size)])
 
     def _generate_mutations(self, data_size, block_size):
         raise NotImplementedError('should be implemented by subclasses')
@@ -380,7 +380,7 @@
     def _testBase(self, data_size, block_size):
         uut = self._get_field(data_size, block_size)
         expected_mutations = self._generate_mutations(data_size, block_size)
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertGreaterEqual(len(mutations), len(expected_mutations))
         for em in expected_mutations:
             self.assertIn(em, mutations)
@@ -470,7 +470,7 @@
 
     def _generate_mutations(self, data_size, block_size):
         full_data = self._default_value(data_size)
-        return map(lambda x: full_data[:x] + full_data[x + block_size:], range(data_size - block_size + 1))
+        return [full_data[:x] + full_data[x + block_size:] for x in range(data_size - block_size + 1)]
 
     def _get_field(self, data_size, block_size):
         return BlockRemove(self._default_value(data_size), block_size)
@@ -487,7 +487,7 @@
     def _generate_mutations(self, data_size, block_size):
         to_set = self._set_chr * block_size
         full_data = self._default_value(data_size)
-        return map(lambda x: full_data[:x] + to_set + full_data[x + block_size:], range(data_size - block_size + 1))
+        return [full_data[:x] + to_set + full_data[x + block_size:] for x in range(data_size - block_size + 1)]
 
     def _get_field(self, data_size, block_size):
         return BlockSet(self._default_value(data_size), block_size, set_chr=self._set_chr)
@@ -503,7 +503,7 @@
 
     def _generate_mutations(self, data_size, block_size):
         full_data = self._default_value(data_size)
-        return map(lambda x: full_data[:x] + full_data[x:x + block_size] * self._num_dups + full_data[x + block_size:], range(data_size - block_size + 1))
+        return [full_data[:x] + full_data[x:x + block_size] * self._num_dups + full_data[x + block_size:] for x in range(data_size - block_size + 1)]
 
     def _get_field(self, data_size, block_size):
         return BlockDuplicate(self._default_value(data_size), block_size, self._num_dups)
--- .\tests\test_remote_rpc.py	(original)
+++ .\tests\test_remote_rpc.py	(refactored)
@@ -87,7 +87,7 @@
         retval = self.rpc_client.func_with_args(arg1=1, arg2=2)
         self.assertEqual(retval, 1)
         self.stop_server()
-        self.assertEqual(self.called_functions, [('func_with_args', {u'arg1': 1, u'arg2': 2})])
+        self.assertEqual(self.called_functions, [('func_with_args', {'arg1': 1, 'arg2': 2})])
 
     def testCallMultipleTimes(self):
         self.start_server()
@@ -101,10 +101,10 @@
         self.assertEqual(retval, 1)
         self.stop_server()
         self.assertEqual(self.called_functions, [
-            ('func_with_args', {u'arg1': 1, u'arg2': 2}),
-            ('func_with_args', {u'arg1': 11, u'arg2': 22}),
-            ('func_with_args', {u'arg1': 111, u'arg2': 222}),
-            ('func_with_args', {u'arg1': 1111, u'arg2': 2222}),
+            ('func_with_args', {'arg1': 1, 'arg2': 2}),
+            ('func_with_args', {'arg1': 11, 'arg2': 22}),
+            ('func_with_args', {'arg1': 111, 'arg2': 222}),
+            ('func_with_args', {'arg1': 1111, 'arg2': 2222}),
         ])
 
     def testCallWithString(self):
@@ -112,7 +112,7 @@
         retval = self.rpc_client.func_with_args(arg1='hello', arg2='world')
         self.assertEqual(retval, 1)
         self.stop_server()
-        self.assertEqual(self.called_functions, [('func_with_args', {u'arg1': 'hello', u'arg2': 'world'})])
+        self.assertEqual(self.called_functions, [('func_with_args', {'arg1': 'hello', 'arg2': 'world'})])
 
     def testCallWithDict(self):
         arg = {'k1': 'hello', 'k2': 1}
@@ -120,7 +120,7 @@
         retval = self.rpc_client.func_with_args(arg=arg)
         self.assertEqual(retval, 1)
         self.stop_server()
-        self.assertEqual(self.called_functions, [('func_with_args', {u'arg': arg})])
+        self.assertEqual(self.called_functions, [('func_with_args', {'arg': arg})])
 
     def testCallWithArr(self):
         arg = ['a string', 123]
@@ -128,7 +128,7 @@
         retval = self.rpc_client.func_with_args(arg=arg)
         self.assertEqual(retval, 1)
         self.stop_server()
-        self.assertEqual(self.called_functions, [('func_with_args', {u'arg': arg})])
+        self.assertEqual(self.called_functions, [('func_with_args', {'arg': arg})])
 
     def testCallWithNone(self):
         arg = None
@@ -136,7 +136,7 @@
         retval = self.rpc_client.func_with_args(arg=arg)
         self.assertEqual(retval, 1)
         self.stop_server()
-        self.assertEqual(self.called_functions, [('func_with_args', {u'arg': arg})])
+        self.assertEqual(self.called_functions, [('func_with_args', {'arg': arg})])
 
     def testCallNoRetVal(self):
         self.start_server()
@@ -161,5 +161,5 @@
         self.stop_server()
         self.assertEqual(self.called_functions, [
             ('raises_exception', {}),
-            ('func_with_args', {u'arg1': 1, u'arg2': 2}),
+            ('func_with_args', {'arg1': 1, 'arg2': 2}),
         ])
--- .\tests\test_target.py	(original)
+++ .\tests\test_target.py	(refactored)
@@ -90,7 +90,7 @@
         config_report = self.config.get_vals()
         if config_report:
             self.logger.debug('found matching config: %s', repr(config_report))
-            for k, v in config_report.iteritems():
+            for k, v in config_report.items():
                 if k.lower() == 'status':
                     report.set_status(v)
                 else:
--- .\tests\test_test_list.py	(original)
+++ .\tests\test_test_list.py	(refactored)
@@ -34,7 +34,7 @@
             if current is None:
                 break
             first_list.append(current)
-            r.next()
+            next(r)
         self.assertListEqual(first_list, expected_list)
         self.assertListEqual(first_list, sorted(first_list))
         after_reset_list = []
@@ -44,7 +44,7 @@
             if current is None:
                 break
             after_reset_list.append(current)
-            r.next()
+            next(r)
         self.assertListEqual(after_reset_list, first_list)
 
     def _testSimpleNoLast(self, test_str, expected_list):
--- .\tests\mocks\mock_config.py	(original)
+++ .\tests\mocks\mock_config.py	(refactored)
@@ -33,7 +33,7 @@
             if 'global' in full_config:
                 self.config = full_config['global']
             if config_name in full_config:
-                for k, v in full_config[config_name].iteritems():
+                for k, v in full_config[config_name].items():
                     self.config[k] = v
         self.func = None
         self.test_conf = {}
--- .\tests\mocks\mock_target.py	(original)
+++ .\tests\mocks\mock_target.py	(refactored)
@@ -15,8 +15,8 @@
 # You should have received a copy of the GNU General Public License
 # along with Kitty.  If not, see <http://www.gnu.org/licenses/>.
 
-from mock_config import Config
-from mock_instruments import MockInstrumentation
+from .mock_config import Config
+from .mock_instruments import MockInstrumentation
 from kitty.targets.server import ServerTarget
 from kitty.targets.client import ClientTarget
 from kitty.data.report import Report
@@ -55,7 +55,7 @@
         config_report = self.config.get_vals()
         if config_report:
             self.logger.debug('found matching config: %s', repr(config_report))
-            for k, v in config_report.iteritems():
+            for k, v in config_report.items():
                 if k.lower() == 'status':
                     report.set_status(v)
                 else:
@@ -106,7 +106,7 @@
         config_report = self.config.get_vals()
         if config_report:
             self.logger.debug('found matching config: %s', repr(config_report))
-            for k, v in config_report.iteritems():
+            for k, v in config_report.items():
                 if k.lower() == 'status':
                     report.set_status(v)
                 else:
