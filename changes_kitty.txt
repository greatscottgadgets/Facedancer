--- kitty\kitty\model\low_level\condition.py	(original)
+++ kitty\kitty\model\low_level\condition.py	(refactored)
@@ -71,7 +71,7 @@
         :param field: (name of, or) field that should meet the condition
         '''
         super(FieldCondition, self).__init__()
-        if isinstance(field, types.StringTypes):
+        if isinstance(field, (str,)):
             self._field_name = field
             self._field = None
         else:
--- kitty\kitty\model\low_level\encoder.py	(original)
+++ kitty\kitty\model\low_level\encoder.py	(refactored)
@@ -111,7 +111,7 @@
         except UnicodeError:
             # TODO: make it better
             try:
-                encoded = ''.join(unichr(ord(x)) for x in value).encode(self._encoding)
+                encoded = ''.join(chr(ord(x)) for x in value).encode(self._encoding)
             except UnicodeError:
                 encoded = value
 
--- kitty\kitty\model\low_level\field.py	(original)
+++ kitty\kitty\model\low_level\field.py	(refactored)
@@ -504,7 +504,7 @@
                 String('this is the default value', max_size=5)
         '''
         self._max_size = None if max_size is None else max_size
-        if isinstance(value, unicode):
+        if isinstance(value, str):
             value = value.encode('utf-8')
         super(String, self).__init__(value=value, encoder=encoder, fuzzable=fuzzable, name=name)
 
@@ -1109,7 +1109,7 @@
                 RandomBits(value='1234', min_length=0, max_length=75, unused_bits=0, step=15)
                 RandomBits(value='1234', min_length=0, max_length=75, unused_bits=3, num_mutations=80)
         '''
-        if unused_bits not in range(8):
+        if unused_bits not in list(range(8)):
             raise KittyException('unused bits (%d) is not between 0-7' % unused_bits)
         value = Bits(bytes=value)
         if unused_bits:
--- kitty\kitty\model\low_level\mutated_field.py	(original)
+++ kitty\kitty\model\low_level\mutated_field.py	(refactored)
@@ -60,7 +60,7 @@
         :raises: ``KittyException`` if num_bits is bigger than the value length in bits
         :raises: ``KittyException`` if num_bits is not positive
         '''
-        kassert.is_of_types(value, types.StringTypes)
+        kassert.is_of_types(value, (str,))
         if len(value) * 8 < num_bits:
             raise KittyException('len of value in bits(%d) < num_bits(%d)' % (len(value) * 8, num_bits))
         if num_bits <= 0:
@@ -78,7 +78,7 @@
     def _mutate(self):
         new_val = BitArray(self._default_value).copy()
         start, end = self._start_end()
-        new_val.invert(range(start, end))
+        new_val.invert(list(range(start, end)))
         self.set_current_value(Bits(new_val))
 
     def get_info(self):
@@ -122,7 +122,7 @@
         :raises: ``KittyException`` if num_bytes is bigger than the value length
         :raises: ``KittyException`` if num_bytes is not positive
         '''
-        kassert.is_of_types(value, types.StringTypes)
+        kassert.is_of_types(value, (str,))
         if len(value) < num_bytes:
             raise KittyException('len(value) <= num_bytes', (len(value), num_bytes))
         if num_bytes <= 0:
@@ -280,7 +280,7 @@
     Perform bit-flip mutations of (N..) sequential bits on the value
     '''
 
-    def __init__(self, value, bits_range=range(1, 5), fuzzable=True, name=None):
+    def __init__(self, value, bits_range=list(range(1, 5)), fuzzable=True, name=None):
         '''
         :type value: str
         :param value: value to mutate
--- kitty\kitty\remote\rpc.py	(original)
+++ kitty\kitty\remote\rpc.py	(refactored)
@@ -28,7 +28,7 @@
     import codecs
 
 
-JSONRPC_NO_RESULT_STR = u'No result from JSON-RPC method.'
+JSONRPC_NO_RESULT_STR = 'No result from JSON-RPC method.'
 
 JSONRPC_PARSE_ERROR = -32700
 JSONRPC_METHOD_NOT_FOUND = -32601
@@ -83,7 +83,7 @@
     elif isinstance(data, list):
         return [encode_data(x) for x in data]
     elif isinstance(data, dict):
-        return {k: encode_data(v) for k, v in data.items()}
+        return {k: encode_data(v) for k, v in list(data.items())}
     else:
         raise ValueError('Cannot encode data of type %s' % type(data))
 
@@ -105,7 +105,7 @@
     elif isinstance(data, list):
         return [decode_data(x) for x in data]
     elif isinstance(data, dict):
-        return {k: decode_data(v) for k, v in data.items()}
+        return {k: decode_data(v) for k, v in list(data.items())}
     else:
         raise ValueError('Cannot decode data of type %s' % type(data))
 
@@ -228,7 +228,7 @@
         try:
             self._parse_request()
         except Exception as ex1:
-            print(traceback.format_exc())
+            print((traceback.format_exc()))
             self.error_response(JSONRPC_PARSE_ERROR, 'exception when parsing jsonrpc request [%s]' % (ex1))
             return
         try:
@@ -317,7 +317,7 @@
         '''
         Serving loop
         '''
-        print('Waiting for a client to connect to url http://%s:%d/' % (self.host, self.port))
+        print(('Waiting for a client to connect to url http://%s:%d/' % (self.host, self.port)))
         self.state = RpcServer._STATE_RUN
         while self.state == RpcServer._STATE_RUN:
             self.server.handle_request()
--- kitty\tests\test_fuzzer_client.py	(original)
+++ kitty\tests\test_fuzzer_client.py	(refactored)
@@ -169,7 +169,7 @@
         self.fuzzer.wait_until_done()
         info = self.fuzzer._get_session_info()
         reports = self.fuzzer.dataman.get_report_test_ids()
-        self.assertEqual(sorted(reports), sorted([int(x) for x in config.keys() if x != 'always']))
+        self.assertEqual(sorted(reports), sorted([int(x) for x in list(config.keys()) if x != 'always']))
         self.assertEqual(info.failure_count, len(config) - 1)
 
     def testAllFailedTestsHaveReports(self):
@@ -186,7 +186,7 @@
         self.fuzzer.wait_until_done()
         info = self.fuzzer._get_session_info()
         reports = self.fuzzer.dataman.get_report_test_ids()
-        self.assertEqual(sorted(reports), sorted([int(x) for x in config.keys() if x != 'always']))
+        self.assertEqual(sorted(reports), sorted([int(x) for x in list(config.keys()) if x != 'always']))
         self.assertEqual(info.failure_count, len(config) - 1)
 
     def testStoringAllReportsWhenStoreAllReportsIsSetToTrue(self):
@@ -234,7 +234,7 @@
         self.fuzzer.start()
         self.fuzzer.wait_until_done()
         self.assertIn(0, self.mutations)
-        self.assertEquals(self.mutations[0][0][0], self._default_stage)
+        self.assertEqual(self.mutations[0][0][0], self._default_stage)
         self.assertIsNotNone(self.mutations[0][0][1])
 
     def testGetMutationForStageTwice(self):
@@ -255,9 +255,9 @@
         self.fuzzer.start()
         self.fuzzer.wait_until_done()
         self.assertIn(0, self.mutations)
-        self.assertEquals(self.mutations[0][0][0], self._default_stage)
+        self.assertEqual(self.mutations[0][0][0], self._default_stage)
         self.assertIsNotNone(self.mutations[0][0][1])
-        self.assertEquals(self.mutations[0][1][0], self._default_stage)
+        self.assertEqual(self.mutations[0][1][0], self._default_stage)
         self.assertIsNotNone(self.mutations[0][1][1])
 
     def testGetMutationWrongStage(self):
@@ -278,7 +278,7 @@
         self.fuzzer.start()
         self.fuzzer.wait_until_done()
         self.assertIn(0, self.mutations)
-        self.assertEquals(self.mutations[0][0][0], wrong_stage)
+        self.assertEqual(self.mutations[0][0][0], wrong_stage)
         self.assertIsNone(self.mutations[0][0][1])
 
     def testGetMutationWrongAfterCorrectStage(self):
@@ -300,9 +300,9 @@
         self.fuzzer.start()
         self.fuzzer.wait_until_done()
         self.assertIn(0, self.mutations)
-        self.assertEquals(self.mutations[0][0][0], self._default_stage)
+        self.assertEqual(self.mutations[0][0][0], self._default_stage)
         self.assertIsNotNone(self.mutations[0][0][1])
-        self.assertEquals(self.mutations[0][1][0], wrong_stage)
+        self.assertEqual(self.mutations[0][1][0], wrong_stage)
         self.assertIsNone(self.mutations[0][1][1])
 
     def testGetMutationCorrectAfterWrongStage(self):
@@ -324,9 +324,9 @@
         self.fuzzer.start()
         self.fuzzer.wait_until_done()
         self.assertIn(0, self.mutations)
-        self.assertEquals(self.mutations[0][0][0], wrong_stage)
+        self.assertEqual(self.mutations[0][0][0], wrong_stage)
         self.assertIsNone(self.mutations[0][0][1])
-        self.assertEquals(self.mutations[0][1][0], self._default_stage)
+        self.assertEqual(self.mutations[0][1][0], self._default_stage)
         self.assertIsNotNone(self.mutations[0][1][1])
 
     def testGetMutationWithWildcard(self):
@@ -346,5 +346,5 @@
         self.fuzzer.start()
         self.fuzzer.wait_until_done()
         self.assertIn(0, self.mutations)
-        self.assertEquals(self.mutations[0][0][0], ClientFuzzer.STAGE_ANY)
+        self.assertEqual(self.mutations[0][0][0], ClientFuzzer.STAGE_ANY)
         self.assertIsNotNone(self.mutations[0][0][1])
--- kitty\tests\test_fuzzer_server.py	(original)
+++ kitty\tests\test_fuzzer_server.py	(refactored)
@@ -204,7 +204,7 @@
         self.fuzzer.set_target(self.target)
         self.fuzzer.start()
         pre_test_list = self.target.instrument.list_get('pre_test')
-        self.assertListEqual(pre_test_list, range(2, 11))
+        self.assertListEqual(pre_test_list, list(range(2, 11)))
 
         os.remove(session_file_name)
 
@@ -229,7 +229,7 @@
         self.fuzzer.set_target(self.target)
         self.fuzzer.start()
         pre_test_list = self.target.instrument.list_get('pre_test')
-        self.assertListEqual(pre_test_list, range(-1, 11))
+        self.assertListEqual(pre_test_list, list(range(-1, 11)))
         self.fuzzer.stop()
 
         self.logger.info('Now use the same session file to rerun failed tests')
@@ -313,7 +313,7 @@
         self.fuzzer.start()
         info = self.fuzzer._get_session_info()
         reports = self.fuzzer.dataman.get_report_test_ids()
-        self.assertEqual(reports, [int(x) for x in config.keys()])
+        self.assertEqual(reports, [int(x) for x in list(config.keys())])
         self.assertEqual(info.failure_count, len(config))
 
     def testAllFailedTestsHaveReports(self):
@@ -328,7 +328,7 @@
         self.fuzzer.start()
         info = self.fuzzer._get_session_info()
         reports = self.fuzzer.dataman.get_report_test_ids()
-        self.assertEqual(reports, sorted([int(x) for x in config.keys()]))
+        self.assertEqual(reports, sorted([int(x) for x in list(config.keys())]))
         self.assertEqual(info.failure_count, len(config))
 
     def testStoringAllReportsWhenStoreAllReportsIsSetToTrue(self):
--- kitty\tests\test_model_high_level.py	(original)
+++ kitty\tests\test_model_high_level.py	(refactored)
@@ -88,7 +88,7 @@
                 sequences[sequence] += 1
         self.assertEqual(len(sequences), len(expected_sequences))
         self.logger.debug('check that each sequence appears the appropriate number of times')
-        for sequence, count in sequences.items():
+        for sequence, count in list(sequences.items()):
             seq_templates = [e.dst for e in sequence]
             self.assertIn(seq_templates, expected_sequences)
             last = seq_templates[-1]
@@ -235,7 +235,7 @@
         self.logger = get_test_logger()
         self.logger.debug('TESTING METHOD: %s', self._testMethodName)
         self.stage_lengths = self.get_stage_map()
-        self.stages = self.stage_lengths.keys()
+        self.stages = list(self.stage_lengths.keys())
         self.todo = []
 
     def get_stage_map(self):
--- kitty\tests\test_model_low_level_calculated.py	(original)
+++ kitty\tests\test_model_low_level_calculated.py	(refactored)
@@ -439,7 +439,7 @@
             ])
         rendered = container.render()
         self.assertEqual(len(rendered), self.length)
-        self.assertEquals(unpack('>I', rendered.tobytes())[0], self.length / 8)
+        self.assertEqual(unpack('>I', rendered.tobytes())[0], self.length / 8)
 
 
 class SizeInBytesTest(CalculatedTestCase):
--- kitty\tests\test_model_low_level_container.py	(original)
+++ kitty\tests\test_model_low_level_container.py	(refactored)
@@ -169,11 +169,11 @@
         rendered = container.render()
         for i in range(10):
             self.assertFalse(container.mutate())
-            self.assertEquals(container.render(), rendered)
+            self.assertEqual(container.render(), rendered)
         container.reset()
         for i in range(10):
             self.assertFalse(container.mutate())
-            self.assertEquals(container.render(), rendered)
+            self.assertEqual(container.render(), rendered)
 
     @metaTest
     def testNotFuzzable1(self):
@@ -222,13 +222,13 @@
             Group(name='test_group_5', values=['A', 'B', 'C'])
         ]
         container = self.get_default_container(fields)
-        expected_list = filter(lambda x: len(x.render()), fields)
+        expected_list = [x for x in fields if len(x.render())]
         if len(container.render()):
             self.assertListEqual(container.get_rendered_fields(), expected_list)
         else:
             self.assertListEqual(container.get_rendered_fields(), [])
         while container.mutate():
-            expected_list = filter(lambda x: len(x.render()), fields)
+            expected_list = [x for x in fields if len(x.render())]
             if len(container.render()):
                 self.assertEqual(container.get_rendered_fields(), expected_list)
             else:
@@ -840,7 +840,7 @@
         key_field = self.get_default_key_field()
         container = Container([uut, key_field])
         num_mutations = uut.num_mutations()
-        actual_num_mutations = sum(v.num_mutations() for k, v in field_dict.items())
+        actual_num_mutations = sum(v.num_mutations() for k, v in list(field_dict.items()))
         self.assertGreaterEqual(num_mutations, actual_num_mutations)
         del container
 
@@ -1040,7 +1040,7 @@
 
     def testRendersToEmptyBits(self):
         uut = PseudoTemplate('uut')
-        self.assertEquals(uut.render(), Bits())
+        self.assertEqual(uut.render(), Bits())
 
     def testNotFuzzable(self):
         uut = PseudoTemplate('uut')
--- kitty\tests\test_model_low_level_encoders.py	(original)
+++ kitty\tests\test_model_low_level_encoders.py	(refactored)
@@ -87,7 +87,7 @@
         expected_len = self._multibyte_len(bitfield._default_value)
         # bitfield.mutate()
         rendered = bitfield.render()
-        self.assertEquals(expected_len, len(rendered))
+        self.assertEqual(expected_len, len(rendered))
 
     def testUnsignedLength8(self):
         bitfield = BitField(
--- kitty\tests\test_model_low_level_fields.py	(original)
+++ kitty\tests\test_model_low_level_fields.py	(refactored)
@@ -198,9 +198,9 @@
     @metaTest
     def testReturnTypeMutateFuzzable(self):
         field = self.get_default_field(fuzzable=True)
-        self.assertIsInstance(field.mutate(), types.BooleanType)
-        field.reset()
-        self.assertIsInstance(field.mutate(), types.BooleanType)
+        self.assertIsInstance(field.mutate(), bool)
+        field.reset()
+        self.assertIsInstance(field.mutate(), bool)
 
     @metaTest
     def testReturnTypeRenderNotFuzzable(self):
@@ -223,9 +223,9 @@
     @metaTest
     def testReturnTypeMutateNotFuzzable(self):
         field = self.get_default_field(fuzzable=False)
-        self.assertIsInstance(field.mutate(), types.BooleanType)
-        field.reset()
-        self.assertIsInstance(field.mutate(), types.BooleanType)
+        self.assertIsInstance(field.mutate(), bool)
+        field.reset()
+        self.assertIsInstance(field.mutate(), bool)
 
     @metaTest
     def testHashTheSameForTwoSimilarObjects(self):
--- kitty\tests\test_model_low_level_mutated.py	(original)
+++ kitty\tests\test_model_low_level_mutated.py	(refactored)
@@ -23,15 +23,15 @@
         len_in_bits = len(value) * 8
         uut = self.get_field(value=value, num_bits=num_bits_to_flip)
         self.assertEqual(uut.num_mutations(), len_in_bits - num_bits_to_flip + 1)
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertEqual(set(mutations), set(expected_mutations))
 
     def testFlipSingleBitOnSingleByte(self):
-        expected_mutations = map(lambda i: chr(1 << i), range(8))
+        expected_mutations = [chr(1 << i) for i in range(8)]
         self._testBase(b'\x00', 1, expected_mutations)
 
     def testFlipTwoBitsOnSingleByte(self):
-        expected_mutations = map(lambda i: chr(3 << i), range(7))
+        expected_mutations = [chr(3 << i) for i in range(7)]
         self._testBase(b'\x00', 2, expected_mutations)
 
     def testFlipAllBitsOnSingleByte(self):
@@ -39,19 +39,19 @@
         self._testBase(b'\x00', 8, expected_mutations)
 
     def testFlipSingleBitOnTwoBytes(self):
-        expected_mutations = map(lambda i: pack('>H', 1 << i), range(16))
+        expected_mutations = [pack('>H', 1 << i) for i in range(16)]
         self._testBase(b'\x00\x00', 1, expected_mutations)
 
     def testFlipTwoBitsOnTwoBytes(self):
-        expected_mutations = map(lambda i: pack('>H', 3 << i), range(15))
+        expected_mutations = [pack('>H', 3 << i) for i in range(15)]
         self._testBase(b'\x00\x00', 2, expected_mutations)
 
     def testFlipTenBitsOnTwoBytes(self):
-        expected_mutations = map(lambda i: pack('>H', 0x3ff << i), range(7))
+        expected_mutations = [pack('>H', 0x3ff << i) for i in range(7)]
         self._testBase(b'\x00\x00', 10, expected_mutations)
 
     def testFlipAllBitsOnTwoBytes(self):
-        expected_mutations = map(lambda i: pack('>H', 0xffff << i), range(1))
+        expected_mutations = [pack('>H', 0xffff << i) for i in range(1)]
         self._testBase(b'\x00\x00', 16, expected_mutations)
 
     def testFuzzableIsFalse(self):
@@ -107,30 +107,30 @@
         total_bits = num_bytes * 8
         for num_bits in num_bits_itr:
             mask = (1 << num_bits) - 1
-            generated.extend(map(lambda x: pack(fmt, mask << x), range(total_bits - num_bits + 1)))
+            generated.extend([pack(fmt, mask << x) for x in range(total_bits - num_bits + 1)])
         return generated
 
     def _testBase(self, num_bytes, itr, uut=None):
         if uut is None:
             uut = BitFlips(b'\x00' * num_bytes, itr)
         expected_mutations = self._generate_mutations(num_bytes, itr)
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertGreaterEqual(len(mutations), len(expected_mutations))
         for em in expected_mutations:
             self.assertIn(em, mutations)
 
     def testSingleByteDefaultRangeIs1to5(self):
         uut = BitFlips(b'\x00')
-        expected_mutations = self._generate_mutations(1, range(1, 5))
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        expected_mutations = self._generate_mutations(1, list(range(1, 5)))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertGreaterEqual(len(mutations), len(expected_mutations))
         for em in expected_mutations:
             self.assertIn(em, mutations)
 
     def testTwoBytesDefaultRangeIs1to5(self):
         uut = BitFlips(b'\x00\x00')
-        expected_mutations = self._generate_mutations(2, range(1, 5))
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        expected_mutations = self._generate_mutations(2, list(range(1, 5)))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertGreaterEqual(len(mutations), len(expected_mutations))
         for em in expected_mutations:
             self.assertIn(em, mutations)
@@ -139,7 +139,7 @@
         self._testBase(1, [1])
 
     def testSingleByteMaximumRange(self):
-        self._testBase(1, range(1, 9))
+        self._testBase(1, list(range(1, 9)))
 
     def testSingleByteArbitraryRange(self):
         self._testBase(1, [1, 4, 6, 3])
@@ -148,7 +148,7 @@
         self._testBase(4, [1])
 
     def testMultipleBytesMaximumRange(self):
-        self._testBase(4, range(1, 33))
+        self._testBase(4, list(range(1, 33)))
 
     def testMultipleBytesArbitraryRange(self):
         self._testBase(4, [5, 19, 22, 27, 6])
@@ -203,10 +203,10 @@
     def _testFlipBytes(self, bytes_to_flip, value_len):
         value = '\x00' * value_len
         nf_count = value_len - bytes_to_flip
-        expected_mutations = map(lambda i: '\x00' * (nf_count - i) + '\xff' * bytes_to_flip + '\x00' * (i), range(nf_count + 1))
+        expected_mutations = ['\x00' * (nf_count - i) + '\xff' * bytes_to_flip + '\x00' * (i) for i in range(nf_count + 1)]
         uut = ByteFlip(value=value, num_bytes=bytes_to_flip)
         self.assertEqual(uut.num_mutations(), value_len - bytes_to_flip + 1)
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertEqual(set(mutations), set(expected_mutations))
 
     def testFlipSingleByteOnSingleByte(self):
@@ -273,7 +273,7 @@
 
     def _generate_single(self, value_len, bytes_to_flip):
         nf_count = value_len - bytes_to_flip
-        expected_mutations = map(lambda i: '\x00' * (nf_count - i) + '\xff' * bytes_to_flip + '\x00' * (i), range(nf_count + 1))
+        expected_mutations = ['\x00' * (nf_count - i) + '\xff' * bytes_to_flip + '\x00' * (i) for i in range(nf_count + 1)]
         return expected_mutations
 
     def _generate_mutations(self, value_len, num_bytes_itr):
@@ -286,7 +286,7 @@
         if uut is None:
             uut = ByteFlips(b'\x00' * num_bytes, itr)
         expected_mutations = self._generate_mutations(num_bytes, itr)
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertGreaterEqual(len(mutations), len(expected_mutations))
         for em in expected_mutations:
             self.assertIn(em, mutations)
@@ -294,7 +294,7 @@
     def testFourByteDefaultRangeIs124(self):
         uut = ByteFlips(b'\x00\x00\x00\x00')
         expected_mutations = self._generate_mutations(4, [1, 2, 4])
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertGreaterEqual(len(mutations), len(expected_mutations))
         for em in expected_mutations:
             self.assertIn(em, mutations)
@@ -302,7 +302,7 @@
     def testTenBytesDefaultRangeIs124(self):
         uut = ByteFlips(b'\x00' * 10)
         expected_mutations = self._generate_mutations(10, [1, 2, 4])
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertGreaterEqual(len(mutations), len(expected_mutations))
         for em in expected_mutations:
             self.assertIn(em, mutations)
@@ -314,7 +314,7 @@
         self._testBase(4, [1])
 
     def testMultipleBytesMaximumRange(self):
-        self._testBase(4, range(1, 5))
+        self._testBase(4, list(range(1, 5)))
 
     def testMultipleBytesArbitraryRange(self):
         self._testBase(20, [7, 12, 9, 3, 19])
@@ -369,7 +369,7 @@
         super(BlockOperationTests, self).setUp(cls)
 
     def _default_value(self, data_size):
-        return ''.join(map(lambda x: chr(x % 0x100), range(data_size)))
+        return ''.join([chr(x % 0x100) for x in range(data_size)])
 
     def _generate_mutations(self, data_size, block_size):
         raise NotImplementedError('should be implemented by subclasses')
@@ -380,7 +380,7 @@
     def _testBase(self, data_size, block_size):
         uut = self._get_field(data_size, block_size)
         expected_mutations = self._generate_mutations(data_size, block_size)
-        mutations = map(lambda x: x.tobytes(), self.get_all_mutations(uut))
+        mutations = [x.tobytes() for x in self.get_all_mutations(uut)]
         self.assertGreaterEqual(len(mutations), len(expected_mutations))
         for em in expected_mutations:
             self.assertIn(em, mutations)
@@ -470,7 +470,7 @@
 
     def _generate_mutations(self, data_size, block_size):
         full_data = self._default_value(data_size)
-        return map(lambda x: full_data[:x] + full_data[x + block_size:], range(data_size - block_size + 1))
+        return [full_data[:x] + full_data[x + block_size:] for x in range(data_size - block_size + 1)]
 
     def _get_field(self, data_size, block_size):
         return BlockRemove(self._default_value(data_size), block_size)
@@ -487,7 +487,7 @@
     def _generate_mutations(self, data_size, block_size):
         to_set = self._set_chr * block_size
         full_data = self._default_value(data_size)
-        return map(lambda x: full_data[:x] + to_set + full_data[x + block_size:], range(data_size - block_size + 1))
+        return [full_data[:x] + to_set + full_data[x + block_size:] for x in range(data_size - block_size + 1)]
 
     def _get_field(self, data_size, block_size):
         return BlockSet(self._default_value(data_size), block_size, set_chr=self._set_chr)
@@ -503,7 +503,7 @@
 
     def _generate_mutations(self, data_size, block_size):
         full_data = self._default_value(data_size)
-        return map(lambda x: full_data[:x] + full_data[x:x + block_size] * self._num_dups + full_data[x + block_size:], range(data_size - block_size + 1))
+        return [full_data[:x] + full_data[x:x + block_size] * self._num_dups + full_data[x + block_size:] for x in range(data_size - block_size + 1)]
 
     def _get_field(self, data_size, block_size):
         return BlockDuplicate(self._default_value(data_size), block_size, self._num_dups)
--- kitty\tests\test_remote_rpc.py	(original)
+++ kitty\tests\test_remote_rpc.py	(refactored)
@@ -87,7 +87,7 @@
         retval = self.rpc_client.func_with_args(arg1=1, arg2=2)
         self.assertEqual(retval, 1)
         self.stop_server()
-        self.assertEqual(self.called_functions, [('func_with_args', {u'arg1': 1, u'arg2': 2})])
+        self.assertEqual(self.called_functions, [('func_with_args', {'arg1': 1, 'arg2': 2})])
 
     def testCallMultipleTimes(self):
         self.start_server()
@@ -101,10 +101,10 @@
         self.assertEqual(retval, 1)
         self.stop_server()
         self.assertEqual(self.called_functions, [
-            ('func_with_args', {u'arg1': 1, u'arg2': 2}),
-            ('func_with_args', {u'arg1': 11, u'arg2': 22}),
-            ('func_with_args', {u'arg1': 111, u'arg2': 222}),
-            ('func_with_args', {u'arg1': 1111, u'arg2': 2222}),
+            ('func_with_args', {'arg1': 1, 'arg2': 2}),
+            ('func_with_args', {'arg1': 11, 'arg2': 22}),
+            ('func_with_args', {'arg1': 111, 'arg2': 222}),
+            ('func_with_args', {'arg1': 1111, 'arg2': 2222}),
         ])
 
     def testCallWithString(self):
@@ -112,7 +112,7 @@
         retval = self.rpc_client.func_with_args(arg1='hello', arg2='world')
         self.assertEqual(retval, 1)
         self.stop_server()
-        self.assertEqual(self.called_functions, [('func_with_args', {u'arg1': 'hello', u'arg2': 'world'})])
+        self.assertEqual(self.called_functions, [('func_with_args', {'arg1': 'hello', 'arg2': 'world'})])
 
     def testCallWithDict(self):
         arg = {'k1': 'hello', 'k2': 1}
@@ -120,7 +120,7 @@
         retval = self.rpc_client.func_with_args(arg=arg)
         self.assertEqual(retval, 1)
         self.stop_server()
-        self.assertEqual(self.called_functions, [('func_with_args', {u'arg': arg})])
+        self.assertEqual(self.called_functions, [('func_with_args', {'arg': arg})])
 
     def testCallWithArr(self):
         arg = ['a string', 123]
@@ -128,7 +128,7 @@
         retval = self.rpc_client.func_with_args(arg=arg)
         self.assertEqual(retval, 1)
         self.stop_server()
-        self.assertEqual(self.called_functions, [('func_with_args', {u'arg': arg})])
+        self.assertEqual(self.called_functions, [('func_with_args', {'arg': arg})])
 
     def testCallWithNone(self):
         arg = None
@@ -136,7 +136,7 @@
         retval = self.rpc_client.func_with_args(arg=arg)
         self.assertEqual(retval, 1)
         self.stop_server()
-        self.assertEqual(self.called_functions, [('func_with_args', {u'arg': arg})])
+        self.assertEqual(self.called_functions, [('func_with_args', {'arg': arg})])
 
     def testCallNoRetVal(self):
         self.start_server()
@@ -161,5 +161,5 @@
         self.stop_server()
         self.assertEqual(self.called_functions, [
             ('raises_exception', {}),
-            ('func_with_args', {u'arg1': 1, u'arg2': 2}),
+            ('func_with_args', {'arg1': 1, 'arg2': 2}),
         ])
--- kitty\tests\test_target.py	(original)
+++ kitty\tests\test_target.py	(refactored)
@@ -90,7 +90,7 @@
         config_report = self.config.get_vals()
         if config_report:
             self.logger.debug('found matching config: %s', repr(config_report))
-            for k, v in config_report.iteritems():
+            for k, v in config_report.items():
                 if k.lower() == 'status':
                     report.set_status(v)
                 else:
--- kitty\tests\test_test_list.py	(original)
+++ kitty\tests\test_test_list.py	(refactored)
@@ -34,7 +34,7 @@
             if current is None:
                 break
             first_list.append(current)
-            r.next()
+            next(r)
         self.assertListEqual(first_list, expected_list)
         self.assertListEqual(first_list, sorted(first_list))
         after_reset_list = []
@@ -44,7 +44,7 @@
             if current is None:
                 break
             after_reset_list.append(current)
-            r.next()
+            next(r)
         self.assertListEqual(after_reset_list, first_list)
 
     def _testSimpleNoLast(self, test_str, expected_list):
--- kitty\tests\mocks\mock_config.py	(original)
+++ kitty\tests\mocks\mock_config.py	(refactored)
@@ -33,7 +33,7 @@
             if 'global' in full_config:
                 self.config = full_config['global']
             if config_name in full_config:
-                for k, v in full_config[config_name].iteritems():
+                for k, v in full_config[config_name].items():
                     self.config[k] = v
         self.func = None
         self.test_conf = {}
--- kitty\tests\mocks\mock_target.py	(original)
+++ kitty\tests\mocks\mock_target.py	(refactored)
@@ -15,8 +15,8 @@
 # You should have received a copy of the GNU General Public License
 # along with Kitty.  If not, see <http://www.gnu.org/licenses/>.
 
-from mock_config import Config
-from mock_instruments import MockInstrumentation
+from .mock_config import Config
+from .mock_instruments import MockInstrumentation
 from kitty.targets.server import ServerTarget
 from kitty.targets.client import ClientTarget
 from kitty.data.report import Report
@@ -55,7 +55,7 @@
         config_report = self.config.get_vals()
         if config_report:
             self.logger.debug('found matching config: %s', repr(config_report))
-            for k, v in config_report.iteritems():
+            for k, v in config_report.items():
                 if k.lower() == 'status':
                     report.set_status(v)
                 else:
@@ -106,7 +106,7 @@
         config_report = self.config.get_vals()
         if config_report:
             self.logger.debug('found matching config: %s', repr(config_report))
-            for k, v in config_report.iteritems():
+            for k, v in config_report.items():
                 if k.lower() == 'status':
                     report.set_status(v)
                 else:
